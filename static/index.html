<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CPUNK DHT Monitor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
      color: #e5e7eb;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 16px 40px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .title {
      font-size: 22px;
      font-weight: 700;
    }
    .subtitle {
      font-size: 13px;
      color: #9ca3af;
      margin-top: 4px;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .badge {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      background: #111827;
      border: 1px solid #1f2937;
    }
    .badge.offline {
      background: #7f1d1d;
      border-color: #b91c1c;
      color: #fee2e2;
    }
    .badge.health-ok {
      background: #064e3b;
      border-color: #10b981;
      color: #d1fae5;
    }
    .badge.health-idle {
      background: #78350f;
      border-color: #f59e0b;
      color: #fffbeb;
    }
    .badge.health-stale {
      background: #7f1d1d;
      border-color: #b91c1c;
      color: #fee2e2;
    }
    .badge.health-cold {
      background: #111827;
      border-color: #4b5563;
      color: #e5e7eb;
    }

    .badges {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Tooltip / process info on HEALTH */
    .has-tooltip {
      position: relative;
      cursor: default;
    }

    .tooltip {
      position: absolute;
      top: 110%;
      right: 0;
      min-width: 210px;
      padding: 8px 10px;
      background: rgba(17, 24, 39, 0.95);
      color: #f9fafb;
      font-size: 12px;
      border-radius: 6px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
      opacity: 0;
      pointer-events: none;
      transform: translateY(-4px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 50;
    }

    .tooltip::after {
      content: "";
      position: absolute;
      top: -5px;
      right: 12px;
      border-width: 0 5px 5px 5px;
      border-style: solid;
      border-color: transparent transparent rgba(17, 24, 39, 0.95) transparent;
    }

    .has-tooltip:hover .tooltip {
      opacity: 1;
      transform: translateY(0);
    }

    .tooltip-title {
      font-size: 11px;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      margin: 2px 0;
    }

    .tooltip-row span:first-child {
      color: #d1d5db;
    }

    .tooltip-row span:last-child {
      font-weight: 500;
    }

    /* Timeframe selector */
    .timeframe-switch {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .timeframe-label {
      font-size: 11px;
      color: #9ca3af;
    }
    .tf-btn {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #9ca3af;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }
    .tf-btn:hover {
      border-color: #4b5563;
    }
    .tf-btn.active {
      background: #0ea5e9;
      border-color: #38bdf8;
      color: #020617;
    }

    .spark-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    @media (max-width: 800px) {
      .spark-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    @media (max-width: 560px) {
      .spark-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .spark-card {
      background: radial-gradient(circle at top left, #020617 0, #020617 60%, #000 100%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      padding: 8px 10px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.65);
    }
    .spark-title {
      font-size: 11px;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .spark-wrapper {
      height: 60px;
    }
    .spark-wrapper canvas {
      width: 100%;
      height: 60px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    @media (max-width: 800px) {
      .grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      header {
        flex-direction: column;
        align-items: flex-start;
      }
    }
    @media (max-width: 560px) {
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    @media (max-width: 800px) {
      .grid-2 {
        grid-template-columns: minmax(0, 1fr);
      }
    }


    .card {
      background: radial-gradient(circle at top left, #0b1120 0, #020617 50%, #000 100%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      padding: 12px 14px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.65);
    }
    .metric-label {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .metric-value {
      font-size: 24px;
      font-weight: 600;
    }
    .metric-sub {
      font-size: 11px;
      color: #6b7280;
      margin-top: 2px;
    }
    .charts {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
      gap: 16px;
      margin-bottom: 20px;
    }
    @media (max-width: 900px) {
      .charts {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .chart-card {
      background: radial-gradient(circle at top left, #020617 0, #020617 60%, #000 100%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      padding: 12px 14px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.65);
    }
    .chart-title {
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 6px;
    }

    canvas {
      width: 100%;
    }

    /* Only main charts (Peers / Traffic) */
    .charts canvas {
      height: 390px !important;
    }

    .table-card {
      background: radial-gradient(circle at top left, #020617 0, #020617 60%, #000 100%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      padding: 12px 14px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.65);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th,
    td {
      padding: 6px 4px;
      text-align: left;
      border-bottom: 1px solid rgba(31, 41, 55, 0.8);
    }
    th {
      font-size: 11px;
      color: #9ca3af;
      font-weight: 500;
    }
    tbody tr:last-child td {
      border-bottom: none;
    }
    .ip {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco,
        Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
    }

    .footer {
      margin-top: 16px;
      font-size: 11px;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .footer-right {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .export-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .export-btn {
      font-size: 10px;
      padding: 3px 8px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">CPUNK DHT Peer & Traffic Monitor</div>
        <div class="subtitle" id="subtitle-line">
          Loading node infoâ€¦
        </div>
      </div>

      <div class="header-right">
        <div class="timeframe-switch">
          <span class="timeframe-label" title="Select how far back to show history in charts and metrics.">
            Timeframe:
          </span>
          <button class="tf-btn active" data-range="1h" title="Last 1 hour">1h</button>
          <button class="tf-btn" data-range="6h" title="Last 6 hours">6h</button>
          <button class="tf-btn" data-range="24h" title="Last 24 hours">24h</button>
          <button class="tf-btn" data-range="7d" title="Last 7 days">7d</button>
        </div>

        <div class="badges">
          <!-- HEALTH badge + tooltip -->
          <div class="badge health-cold has-tooltip" id="health-badge">
            <span id="health-label">COLD</span>
            <div id="healthTooltip" class="tooltip">
              <div class="tooltip-title">DNA-Nodus process</div>
              <div class="tooltip-row">
                <span>Status</span><span>â€“</span>
              </div>
              <div class="tooltip-row">
                <span>CPU</span><span>â€“</span>
              </div>
              <div class="tooltip-row">
                <span>RAM</span><span>â€“</span>
              </div>
              <div class="tooltip-row">
                <span>Uptime</span><span>â€“</span>
              </div>
            </div>
          </div>

          <div class="badge" id="live-badge" title="Shows if the monitor is still receiving fresh data.">LIVE</div>
        </div>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="metric-label" title="Number of unique IP addresses seen in the last capture window.">
          Current peers (unique IPs)
        </div>
        <div class="metric-value" id="metric-current-peers">0</div>
        <div class="metric-sub" id="metric-max-peers">Max peers: &ndash;</div>
        <div class="metric-sub" id="metric-churn" title="Peer churn in the last capture window (compared to the previous one).">
          Churn: &ndash;
        </div>
      </div>
      <div class="card">
        <div class="metric-label" title="Traffic volume in the last capture window (bytes observed on UDP port 4000).">
          Traffic (last window)
        </div>
        <div class="metric-value" id="metric-current-traffic">0 KB</div>
        <div class="metric-sub" id="metric-max-traffic">Peak window: &ndash;</div>
      </div>
      <div class="card">
        <div class="metric-label" title="Total traffic on the monitored DHT port since the monitor started logging.">
          Total traffic (all time)
        </div>
        <div class="metric-value" id="metric-total-traffic">0 MB</div>
        <div class="metric-sub" id="metric-data-points">Data points: &ndash;</div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="metric-label" title="Overall system CPU usage on this host.">
          CPU usage
        </div>
        <div class="metric-value" id="metric-cpu">â€“</div>
        <div class="metric-sub" id="metric-cpu-sub">Last window</div>
      </div>
      <div class="card">
        <div class="metric-label" title="RAM usage percentage and absolute memory used / total on this host.">
          Memory usage
        </div>
        <div class="metric-value" id="metric-mem">â€“</div>
        <div class="metric-sub" id="metric-mem-sub">â€“</div>
      </div>
      <div class="card">
        <div class="metric-label" title="Root filesystem disk usage on this host.">
          Disk usage (root)
        </div>
        <div class="metric-value" id="metric-disk">â€“</div>
        <div class="metric-sub" id="metric-disk-sub">â€“</div>
      </div>
    </div>
    
    <div class="grid-2">
      <div class="card">
        <div class="metric-label" title="Estimated throughput in the last capture window based on inbound/outbound bytes and packets.">
          Throughput (last window)
        </div>
        <div class="metric-value" id="metric-throughput">â€“</div>
        <div class="metric-sub" id="metric-throughput-sub">â€“</div>
      </div>
    
      <div class="spark-card">
        <div class="spark-title">Throughput KB/s trend</div>
        <div class="spark-wrapper">
          <canvas id="throughputSpark"></canvas>
        </div>
      </div>
    </div>


    <div class="spark-grid">
      <div class="spark-card">
        <div class="spark-title">CPU % trend</div>
        <div class="spark-wrapper">
          <canvas id="cpuSpark"></canvas>
       </div>
      </div>
      <div class="spark-card">
        <div class="spark-title">RAM % trend</div>
        <div class="spark-wrapper">
          <canvas id="memSpark"></canvas>
        </div>
      </div>
      <div class="spark-card">
        <div class="spark-title">Disk % trend</div>
        <div class="spark-wrapper">
          <canvas id="diskSpark"></canvas>
        </div>
      </div>
    </div>

    <div class="charts">
      <div class="chart-card">
        <div class="chart-title">Peers over time</div>
        <canvas id="peersChart"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-title">Traffic over time (KB per window)</div>
        <canvas id="trafficChart"></canvas>
      </div>
    </div>

    <div class="table-card">
      <div class="chart-title">Top talkers (last window)</div>
      <table>
        <thead>
          <tr>
            <th>IP</th>
            <th>Bytes</th>
            <th>Packets</th>
          </tr>
        </thead>
        <tbody id="top-talkers-body">
        </tbody>
      </table>
    </div>

    <div class="footer">
      <div id="iface-line">Interface: â€“</div>
      <div class="footer-right">
        <div>CPUNK / DNA-Messenger infra helper</div>
        <div class="export-buttons">
          <button
            type="button"
            class="tf-btn export-btn"
            onclick="exportJSON()"
            title="Download visible history as JSON">
            Export JSON
          </button>
          <button
            type="button"
            class="tf-btn export-btn"
            onclick="exportCSV()"
            title="Download visible history as CSV">
            Export CSV
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let intervalSeconds = 60; // will be updated from /config.json
    let peersChart;
    let trafficChart;
    let throughputSpark;
    let chartsInitialized = false;

    let lastFetchOk = 0;

    let cpuSpark;
    let memSpark;
    let diskSpark;
    let sparksInitialized = false;

    // timeframe state
    const TIMEFRAME_MS = {
      "1h": 1 * 60 * 60 * 1000,
      "6h": 6 * 60 * 60 * 1000,
      "24h": 24 * 60 * 60 * 1000,
      "7d": 7 * 24 * 60 * 60 * 1000
    };
    let currentTimeframe = "1h";
    let lastHistory = [];
    let lastLatestTop = [];

    // ---- Global Chart.js tooltip + interaction defaults ----
    if (typeof Chart !== "undefined") {
      Chart.defaults.plugins.tooltip.enabled = true;
      Chart.defaults.plugins.tooltip.mode = "nearest";
      Chart.defaults.plugins.tooltip.intersect = false;
      Chart.defaults.plugins.tooltip.backgroundColor = "rgba(15, 23, 42, 0.95)";
      Chart.defaults.plugins.tooltip.titleColor = "#ffffff";
      Chart.defaults.plugins.tooltip.bodyColor = "#cbd5e1";
      Chart.defaults.plugins.tooltip.borderColor = "#475569";
      Chart.defaults.plugins.tooltip.borderWidth = 1;
      Chart.defaults.plugins.tooltip.padding = 10;
      Chart.defaults.plugins.tooltip.titleFont = { size: 12, weight: "bold" };
      Chart.defaults.plugins.tooltip.bodyFont = { size: 12 };
      Chart.defaults.interaction.mode = "index";
      Chart.defaults.interaction.intersect = false;
    }

    function formatBytesToKB(bytes) {
      return (bytes / 1024).toFixed(1);
    }

    function formatBytesToMB(bytes) {
      return (bytes / (1024 * 1024)).toFixed(2);
    }

    function filterHistoryByTimeframe(history, timeframe) {
      const ms = TIMEFRAME_MS[timeframe];
      if (!ms) return history;
      const cutoff = Date.now() - ms;
      const filtered = history.filter(h => {
        if (!h.ts) return false;
        const t = Date.parse(h.ts);
        if (isNaN(t)) return false;
        return t >= cutoff;
      });
      return filtered;
    }

    // Get the history slice for the current timeframe (used by charts + exports)
    function getVisibleHistory() {
      if (!lastHistory || lastHistory.length === 0) return [];
      let visible = filterHistoryByTimeframe(lastHistory, currentTimeframe);
      if (visible.length === 0) {
        visible = lastHistory.slice();
      }
      return visible;
    }

    // Format uptime seconds into "Xd Yh", "Xh Ym", or "Xm"
    function formatUptime(seconds) {
      if (seconds == null || isNaN(seconds)) return "â€“";

      const s = Math.floor(seconds);
      const days = Math.floor(s / 86400);
      const hours = Math.floor((s % 86400) / 3600);
      const mins = Math.floor((s % 3600) / 60);

      if (days > 0) {
        return `${days}d ${hours}h`;
      } else if (hours > 0) {
        return `${hours}h ${mins}m`;
      } else {
        return `${mins}m`;
      }
    }

    function initCharts(labels, peers, trafficInKB, trafficOutKB) {
      const peersCtx = document.getElementById('peersChart').getContext('2d');
      const trafficCtx = document.getElementById('trafficChart').getContext('2d');

      peersChart = new Chart(peersCtx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Unique peers',
            data: peers,
            tension: 0.2,
          }]
        },
        options: {
          responsive: true,
          aspectRatio: false, //1.2,
          interaction: {
            mode: "index",
            intersect: false
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                title: function(context) {
                  const label = context[0].label || "";
                  return "Time: " + label;
                },
                label: function(context) {
                  const value = context.raw;
                  return `Peers: ${value}`;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                maxRotation: 0,
                autoSkip: true,
              }
            },
            y: {
              beginAtZero: true,
              ticks: { precision: 0 }
            }
          }
        }
      });

      trafficChart = new Chart(trafficCtx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Inbound KB',
              data: trafficInKB,
              tension: 0.2,
            },
            {
              label: 'Outbound KB',
              data: trafficOutKB,
              tension: 0.2,
            }
          ]
        },
        options: {
          responsive: true,
          aspectRatio: false, //1.2,
          interaction: {
            mode: "index",
            intersect: false
          },
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                title: function(context) {
                  const label = context[0].label || "";
                  return "Time: " + label;
                },
                label: function(context) {
                  const value = context.raw;
                  const label = context.dataset.label || "Traffic";
                  const v = (typeof value === "number" ? value : 0).toFixed(1);
                  return `${label}: ${v} KB`;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                maxRotation: 0,
                autoSkip: true,
              }
            },
            y: {
              beginAtZero: true
            }
          }
        }
      });

      chartsInitialized = true;
    }

    function updateCharts(labels, peers, trafficInKB, trafficOutKB) {
      if (!peersChart || !trafficChart) return;

      peersChart.data.labels = labels;
      peersChart.data.datasets[0].data = peers;
      peersChart.update('none');

      trafficChart.data.labels = labels;
      trafficChart.data.datasets[0].data = trafficInKB;
      trafficChart.data.datasets[1].data = trafficOutKB;
      trafficChart.update('none');
    }

    // ---- Sparklines ----

    function initSparklines(cpuSeries, memSeries, diskSeries, throughputSeries, labels) {
      const cpuCtx = document.getElementById('cpuSpark').getContext('2d');
      const memCtx = document.getElementById('memSpark').getContext('2d');
      const diskCtx = document.getElementById('diskSpark').getContext('2d');
      const thrCtx = document.getElementById('throughputSpark').getContext('2d');
    
      const xLabels = labels && labels.length === cpuSeries.length
        ? labels
        : Array(cpuSeries.length).fill("");
    
      const baseOptions = {
        responsive: true,
        maintainAspectRatio: false,
        layout: { padding: 0 },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: true,
            callbacks: {
              label: function(context) {
                const value = context.raw;
                const id = context.chart.canvas.id;
                if (id === "cpuSpark") {
                  return `CPU: ${value.toFixed(1)}%`;
                }
                if (id === "memSpark") {
                  return `RAM: ${value.toFixed(1)}%`;
                }
                if (id === "diskSpark") {
                  return `Disk: ${value.toFixed(1)}%`;
                }
                if (id === "throughputSpark") {
                  return `Throughput: ${value.toFixed(1)} KB/s`;
                }
                return value;
              },
              title: function(context) {
                return context[0].label || "";
              }
            }
          }
        },
        scales: {
          x: {
            display: true,
            grid: { display: false },
            border: { display: false },
            ticks: {
              maxRotation: 0,
              autoSkip: true,
            }
          },
          y: {
            display: false,
            grid: { display: false },
            border: { display: false }
          }
        },
        elements: {
          point: { radius: 0 },
          line: { borderWidth: 2 }
        }
      };
    
      cpuSpark = new Chart(cpuCtx, {
        type: 'line',
        data: {
          labels: xLabels,
          datasets: [{
            data: cpuSeries,
            tension: 0.2,
          }]
        },
        options: baseOptions
      });
    
      memSpark = new Chart(memCtx, {
        type: 'line',
        data: {
          labels: xLabels,
          datasets: [{
            data: memSeries,
            tension: 0.2,
          }]
        },
        options: baseOptions
      });
    
      diskSpark = new Chart(diskCtx, {
        type: 'line',
        data: {
          labels: xLabels,
          datasets: [{
            data: diskSeries,
            tension: 0.2,
          }]
        },
        options: baseOptions
      });
    
      throughputSpark = new Chart(thrCtx, {
        type: 'line',
        data: {
          labels: xLabels,
          datasets: [{
            data: throughputSeries,
            tension: 0.2,
          }]
        },
        options: baseOptions
      });
    
      sparksInitialized = true;
    }



    function updateSparklines(cpuSeries, memSeries, diskSeries, throughputSeries, labels) {
      if (!cpuSpark || !memSpark || !diskSpark || !throughputSpark) return;
    
      const xLabels = labels && labels.length === cpuSeries.length
        ? labels
        : Array(cpuSeries.length).fill("");
    
      cpuSpark.data.labels = xLabels;
      cpuSpark.data.datasets[0].data = cpuSeries;
      cpuSpark.update('none');
    
      memSpark.data.labels = xLabels;
      memSpark.data.datasets[0].data = memSeries;
      memSpark.update('none');
    
      diskSpark.data.labels = xLabels;
      diskSpark.data.datasets[0].data = diskSeries;
      diskSpark.update('none');
    
      throughputSpark.data.labels = xLabels;
      throughputSpark.data.datasets[0].data = throughputSeries;
      throughputSpark.update('none');
    }




    // ---- Rendering from history ----

    function renderMetrics(history, latestTop) {
      const dataPointsEl = document.getElementById('metric-data-points');

    if (!history || history.length === 0) {
      dataPointsEl.textContent = "Data points: 0";
      document.getElementById('metric-current-peers').textContent = "0";
      document.getElementById('metric-current-traffic').textContent = "0 KB";
      document.getElementById('metric-total-traffic').textContent = "0 MB";
      document.getElementById('metric-max-peers').textContent = "Max peers: â€“";
      document.getElementById('metric-max-traffic').textContent = "Peak window: â€“";
      document.getElementById('metric-churn').textContent = "Churn: â€“";

      const thr = document.getElementById('metric-throughput');
      const thrSub = document.getElementById('metric-throughput-sub');
      if (thr) thr.textContent = "â€“";
      if (thrSub) thrSub.textContent = "â€“";
 
      updateTopTalkers([]);
      return;
    }
      // Apply timeframe (same as export will use)
      let visibleHistory = getVisibleHistory();
      dataPointsEl.textContent = "Data points: " + visibleHistory.length;

      // Labels / peers for visible window
      const labels = visibleHistory.map(h => {
        const ts = h.ts;
        if (!ts) return "";
        const d = new Date(ts);
        if (isNaN(d.getTime())) return "";
        return d.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        });
      });

      const peers = visibleHistory.map(h => h.unique_peers || 0);

      // Traffic: inbound/outbound series (KB)
      const inboundKB = visibleHistory.map(h => {
        if (typeof h.in_bytes === "number") {
          return h.in_bytes / 1024.0;
        }
        // fallback: when old data has no in_bytes, treat all as inbound
        const tb = h.total_bytes || 0;
        return tb / 1024.0;
      });

      const outboundKB = visibleHistory.map(h => {
        if (typeof h.out_bytes === "number") {
          return h.out_bytes / 1024.0;
        }
        // fallback: 0 when no separate outbound data
        return 0;
      });

      // System metric series for sparklines (visible window)
      const cpuSeries = visibleHistory.map(h => h.cpu_usage);
      const memPctSeries = visibleHistory.map(h => {
        const used = h.mem_used_mb;
        const total = h.mem_total_mb || 1;
        return (used / total) * 100.0;
      });
      const diskSeries = visibleHistory.map(h => h.disk_used_pct);
    // Total throughput series (KB/s) for sparkline
    const windowSec = intervalSeconds || 60;
    const throughputSeries = visibleHistory.map(h => {
      const inB = (typeof h.in_bytes === "number")
        ? h.in_bytes
        : (h.total_bytes || 0);
      const outB = (typeof h.out_bytes === "number")
        ? h.out_bytes
        : 0;
      const sumB = inB + outB;
      if (!windowSec || windowSec <= 0) return 0;
      return sumB / 1024.0 / windowSec; // KB/s total
    });




      // Latest sample always from full history
      const latest = history[history.length - 1];

      document.getElementById('metric-current-peers').textContent =
        latest.unique_peers || 0;

      // Traffic (last window) card: show IN / OUT if available
      const lastIn = typeof latest.in_bytes === "number" ? latest.in_bytes : null;
      const lastOut = typeof latest.out_bytes === "number" ? latest.out_bytes : null;

      let trafficLabel;
      if (lastIn !== null || lastOut !== null) {
        const inText = formatBytesToKB(lastIn || 0);
        const outText = formatBytesToKB(lastOut || 0);
        trafficLabel = `${inText} KB in / ${outText} KB out`;
      } else {
        const lastKB = latest.total_bytes ? formatBytesToKB(latest.total_bytes) : "0.0";
        trafficLabel = `${lastKB} KB total`;
      }

      document.getElementById('metric-current-traffic').textContent = trafficLabel;

      // Total traffic over full history (all time)
      const totalBytes = history.reduce((acc, h) => acc + (h.total_bytes || 0), 0);
      document.getElementById('metric-total-traffic').textContent =
        formatBytesToMB(totalBytes) + " MB";

      // --- System metrics in cards (latest) ---

      // CPU
      const cpu = latest.cpu_usage;
      if (cpu !== undefined && cpu !== null) {
        document.getElementById('metric-cpu').textContent =
          cpu.toFixed(1) + " %";
      } else {
        document.getElementById('metric-cpu').textContent = "â€“";
      }

      // Memory
      const memUsedMb = latest.mem_used_mb;
      const memTotalMb = latest.mem_total_mb;
      if (
        memUsedMb !== undefined && memUsedMb !== null &&
        memTotalMb !== undefined && memTotalMb !== null &&
        memTotalMb > 0
      ) {
        const memPct = (memUsedMb / memTotalMb) * 100;
        document.getElementById('metric-mem').textContent =
          memPct.toFixed(1) + " %";
        document.getElementById('metric-mem-sub').textContent =
          memUsedMb.toFixed(0) + " / " + memTotalMb.toFixed(0) + " MB";
      } else {
        document.getElementById('metric-mem').textContent = "â€“";
        document.getElementById('metric-mem-sub').textContent = "No data";
      }

      // Disk
      const diskPct = latest.disk_used_pct;
      const diskUsedGb = latest.disk_used_gb;
      const diskFreeGb = latest.disk_free_gb;
      if (
        diskPct !== undefined && diskPct !== null &&
        diskUsedGb !== undefined && diskUsedGb !== null &&
        diskFreeGb !== undefined && diskFreeGb !== null
      ) {
        document.getElementById('metric-disk').textContent =
          diskPct.toFixed(1) + " %";
        document.getElementById('metric-disk-sub').textContent =
          diskUsedGb.toFixed(1) + " used / " +
          diskFreeGb.toFixed(1) + " free GB";
      } else {
        document.getElementById('metric-disk').textContent = "â€“";
        document.getElementById('metric-disk-sub').textContent = "No data";
      }

    // Throughput (last window) â€“ KB/s in/out + packets/s
    (function updateThroughputCard() {
      const thr = document.getElementById('metric-throughput');
      const thrSub = document.getElementById('metric-throughput-sub');
      if (!thr || !thrSub) return;

      const windowSec = intervalSeconds || 60;

      // Prefer per-direction metrics if available
      const inBytesWin = (typeof latest.in_bytes === "number")
        ? latest.in_bytes
        : (latest.total_bytes || 0);

      const outBytesWin = (typeof latest.out_bytes === "number")
        ? latest.out_bytes
        : 0;

       // Packets: prefer total_packets, else sum in/out if you ever add them
       let totalPacketsWin;
       if (typeof latest.total_packets === "number") {
        totalPacketsWin = latest.total_packets;
      } else {
        const inP = typeof latest.in_packets === "number" ? latest.in_packets : 0;
        const outP = typeof latest.out_packets === "number" ? latest.out_packets : 0;
        totalPacketsWin = inP + outP;
      }

      if (!windowSec || windowSec <= 0) {
        thr.textContent = "â€“";
        thrSub.textContent = "â€“";
        return;
      }

      const inKBs = inBytesWin / 1024.0 / windowSec;
      const outKBs = outBytesWin / 1024.0 / windowSec;
      const pps = totalPacketsWin / windowSec;

      thr.textContent = `${inKBs.toFixed(1)} / ${outKBs.toFixed(1)} KB/s`;
      thrSub.textContent = `${pps.toFixed(1)} packets/s`;
    })();






      // Max peers in visible window
      const maxPeers = Math.max(...peers);
      document.getElementById('metric-max-peers').textContent =
        "Max peers: " + maxPeers;

      // Peak traffic (IN+OUT if available)
      const maxBytes = visibleHistory.reduce(
        (max, h) => {
          if (typeof h.in_bytes === "number" || typeof h.out_bytes === "number") {
            const sum = (h.in_bytes || 0) + (h.out_bytes || 0);
            return Math.max(max, sum);
          }
          return Math.max(max, h.total_bytes || 0);
        },
        0
      );
      document.getElementById('metric-max-traffic').textContent =
        "Peak window: " + formatBytesToKB(maxBytes) + " KB";

      // Peer churn (last window)
      const newPeers = typeof latest.new_peers === "number" ? latest.new_peers : null;
      const expiredPeers = typeof latest.expired_peers === "number" ? latest.expired_peers : null;

      if (newPeers !== null || expiredPeers !== null) {
        const plus = newPeers !== null ? `+${newPeers}` : "+â€“";
        const minus = expiredPeers !== null ? `-${expiredPeers}` : "-â€“";
        document.getElementById('metric-churn').textContent =
          `Churn: ${plus} / ${minus}`;
      } else {
        document.getElementById('metric-churn').textContent = "Churn: â€“";
      }

    if (!chartsInitialized) {
      initCharts(labels, peers, inboundKB, outboundKB);
    } else {
      updateCharts(labels, peers, inboundKB, outboundKB);
    }

    if (!sparksInitialized) {
      initSparklines(cpuSeries, memPctSeries, diskSeries, throughputSeries, labels);
    } else {
      updateSparklines(cpuSeries, memPctSeries, diskSeries, throughputSeries, labels);
    }

      updateTopTalkers(latestTop);
    }

    // ---- Export helpers ----

    function downloadBlob(content, mimeType, filename) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportJSON() {
      const visible = getVisibleHistory();
      if (!visible || visible.length === 0) {
        alert("No data to export for current timeframe.");
        return;
      }
      const pretty = JSON.stringify(visible, null, 2);
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `dht_metrics_${currentTimeframe}_${ts}.json`;
      downloadBlob(pretty, "application/json", filename);
    }

    function exportCSV() {
      const visible = getVisibleHistory();
      if (!visible || visible.length === 0) {
        alert("No data to export for current timeframe.");
        return;
      }

      // Fixed set of fields we care about
      const fields = [
        "ts",
        "unique_peers",
        "total_bytes",
        "total_packets",
        "in_bytes",
        "out_bytes",
        "in_packets",
        "out_packets",
        "new_peers",
        "expired_peers",
        "cpu_usage",
        "mem_used_mb",
        "mem_total_mb",
        "disk_used_pct",
        "disk_used_gb",
        "disk_free_gb"
      ];

      const header = fields.join(",");
      const lines = [header];

      visible.forEach(row => {
        const line = fields.map(key => {
          let v = row[key];
          if (v === undefined || v === null) return "";
          if (typeof v === "string") {
            const safe = v.replace(/"/g, '""');
            return `"${safe}"`;
          }
          return String(v);
        }).join(",");
        lines.push(line);
      });

      const csv = lines.join("\n");
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `dht_metrics_${currentTimeframe}_${ts}.csv`;
      downloadBlob(csv, "text/csv", filename);
    }

    // ---- Config, fetch & health ----

    async function fetchConfig() {
      try {
        const resp = await fetch("/config.json");
        if (!resp.ok) {
          console.error("config.json HTTP error", resp.status);
          return;
        }
        const cfg = await resp.json();
        if (cfg.interval_seconds) {
          intervalSeconds = cfg.interval_seconds;
        }

        const subtitle = document.getElementById("subtitle-line");
        if (subtitle) {
          subtitle.textContent =
            "Host " + (cfg.hostname || "?") +
            " â€” UDP port " + (cfg.port || "?") +
            " â€¢ updated every " + intervalSeconds + " s";
        }

        const ifaceLine = document.getElementById("iface-line");
        if (ifaceLine && cfg.iface) {
          ifaceLine.textContent = "Interface: " + cfg.iface;
        }
      } catch (e) {
        console.error("Error fetching config:", e);
      }
    }

    async function fetchMetrics() {
      try {
        const resp = await fetch("/metrics.json");
        if (!resp.ok) {
          console.error("metrics.json HTTP error", resp.status);
          return;
        }
        const data = await resp.json();
        lastFetchOk = Date.now();

        const history = data.history || [];
        const latestTop = data.latest_top || [];

        // cache for timeframe switching + exports
        lastHistory = history;
        lastLatestTop = latestTop;

        renderMetrics(history, latestTop);
      } catch (e) {
        console.error("Error fetching metrics:", e);
      }
    }

    function updateTopTalkers(top) {
      const tbody = document.getElementById('top-talkers-body');
      tbody.innerHTML = "";

      if (!top || top.length === 0) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 3;
        td.textContent = "No data in last window";
        td.style.color = "#6b7280";
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      top.forEach(entry => {
        const tr = document.createElement('tr');

        const tdIp = document.createElement('td');
        tdIp.textContent = entry.ip || "";
        tdIp.className = "ip";
        tr.appendChild(tdIp);

        const tdBytes = document.createElement('td');
        tdBytes.textContent = entry.bytes || 0;
        tr.appendChild(tdBytes);

        const tdPackets = document.createElement('td');
        tdPackets.textContent = entry.packets || 0;
        tr.appendChild(tdPackets);

        tbody.appendChild(tr);
      });
    }

    function updateLiveBadge() {
      const badge = document.getElementById('live-badge');
      if (!badge) return;

      const now = Date.now();
      const ageMs = now - lastFetchOk;

      if (ageMs > intervalSeconds * 3 * 1000) {
        badge.textContent = "OFFLINE";
        badge.classList.add("offline");
      } else {
        badge.textContent = "LIVE";
        badge.classList.remove("offline");
      }
    }

    // ---- HEALTH tooltip content update ----
    function updateHealthTooltip(data) {
      const tooltip = document.getElementById("healthTooltip");
      if (!tooltip || !data) return;

      const running = data.nodus_running;
      const cpuVal = data.nodus_cpu_pct;
      const memVal = data.nodus_mem_mb;
      const uptimeSec = data.nodus_uptime_seconds;

      const statusText =
        running === 1
          ? "ðŸŸ¢ Running"
          : running === 0
          ? "ðŸ”´ Not running"
          : "â€“";

      const cpuText =
        typeof cpuVal === "number"
          ? cpuVal.toFixed(1) + " %"
          : "â€“";

      const memText =
        typeof memVal === "number"
          ? memVal.toFixed(1) + " MB"
          : "â€“";

      const uptimeText = formatUptime(uptimeSec);

      tooltip.innerHTML = `
        <div class="tooltip-title">DNA-Nodus process</div>
        <div class="tooltip-row">
          <span>Status</span><span>${statusText}</span>
        </div>
        <div class="tooltip-row">
          <span>CPU</span><span>${cpuText}</span>
        </div>
        <div class="tooltip-row">
          <span>RAM</span><span>${memText}</span>
        </div>
        <div class="tooltip-row">
          <span>Uptime</span><span>${uptimeText}</span>
        </div>
      `;
    }

    async function fetchHealth() {
      const badge = document.getElementById('health-badge');
      const labelSpan = document.getElementById('health-label');
      if (!badge || !labelSpan) return;

      try {
        const resp = await fetch("/health");
        if (!resp.ok) {
          labelSpan.textContent = "ERROR";
          badge.classList.remove("health-ok", "health-idle", "health-cold", "health-stale");
          badge.classList.add("health-stale");
          return;
        }

        const data = await resp.json();
        console.log("Health data:", data);

        const status = (data.status || "unknown").toLowerCase();

        // Reset health classes
        badge.classList.remove("health-ok", "health-idle", "health-cold", "health-stale");

        let label = "UNKNOWN";

        switch (status) {
          case "ok":
            label = "OK";
            badge.classList.add("health-ok");
            break;
          case "idle":
            label = "IDLE";
            badge.classList.add("health-idle");
            break;
          case "cold":
            label = "COLD";
            badge.classList.add("health-cold");
            break;
          default:
            label = status.toUpperCase();
            badge.classList.add("health-cold");
            break;
        }

        labelSpan.textContent = label;

        // Update tooltip with dna-nodus process metrics
        updateHealthTooltip(data);
      } catch (e) {
        console.error("Error fetching health:", e);
        const badge = document.getElementById('health-badge');
        const labelSpan = document.getElementById('health-label');
        if (badge && labelSpan) {
          labelSpan.textContent = "ERROR";
          badge.classList.remove("health-ok", "health-idle", "health-cold", "health-stale");
          badge.classList.add("health-stale");
        }
      }
    }

    function setupTimeframeButtons() {
      const buttons = document.querySelectorAll('.tf-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const tf = btn.dataset.range;
          if (!tf || tf === currentTimeframe) return;
          currentTimeframe = tf;
          buttons.forEach(b => b.classList.toggle('active', b === btn));

          if (lastHistory.length > 0) {
            renderMetrics(lastHistory, lastLatestTop);
          }
        });
      });
    }

    async function initDashboard() {
      setupTimeframeButtons();
      await fetchConfig();
      await fetchMetrics();
      await fetchHealth();
      setInterval(fetchMetrics, intervalSeconds * 1000);
      setInterval(fetchHealth, intervalSeconds * 1000);
      setInterval(updateLiveBadge, 1000);
    }

    initDashboard();
  </script>
</body>
</html>
